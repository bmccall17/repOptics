/**
 * Hand-off Artifact Generator
 *
 * Generates a "Decisions Made" document capturing the user's choices
 * during the Project Generator Wizard. This document is included in
 * the generated ZIP file.
 *
 * Based on Max's insight: The real product is a decision-clarity system
 * that produces knowns, unknowns, and next actions.
 */

import {
  DecisionSnapshot,
  summarizeDecisions,
  getQuestionById,
  QUESTION_CATEGORIES,
} from "./questions";

export type HandoffDocument = {
  markdown: string;
  filename: string;
};

export type ProjectConfig = {
  projectName: string;
  description: string;
  includeADR: boolean;
  includeCI: boolean;
  includeGovernance: boolean;
  includeScaffold: boolean;
  includeAIContext: boolean;
  includeDocker: boolean;
};

export function generateHandoffDocument(
  snapshot: DecisionSnapshot,
  config: ProjectConfig
): HandoffDocument {
  const { knowns, unknowns, nextActions } = summarizeDecisions(snapshot);
  const timestamp = new Date().toISOString().split("T")[0];

  const markdown = `# ${config.projectName} - Decisions Made

> Generated by repOptics Project Generator on ${timestamp}

## Overview

This document captures the decisions made during project setup. It serves as a reference for why the project is structured the way it is.

**Project**: ${config.projectName}
**Description**: ${config.description || "(No description provided)"}

---

## Decisions Captured

${formatDecisionsByCategory(snapshot)}

---

## Summary

### What We Know (Decided)

${knowns.length > 0 ? knowns.map(k => `- ${k}`).join("\n") : "- No decisions captured yet"}

### What We Don't Know (Undecided)

${unknowns.length > 0 ? unknowns.map(u => `- ${u}`).join("\n") : "- All key questions answered"}

### Recommended Next Actions

${nextActions.length > 0 ? nextActions.map(a => `- [ ] ${a}`).join("\n") : "- No specific actions recommended based on current decisions"}

---

## Generated Configuration

The following modules were included in this project:

| Module | Included | Purpose |
|--------|----------|---------|
| ADR Templates | ${config.includeADR ? "Yes" : "No"} | Track architecture decisions |
| CI/CD Pipeline | ${config.includeCI ? "Yes" : "No"} | Automated testing and deployment |
| Governance Files | ${config.includeGovernance ? "Yes" : "No"} | CODEOWNERS, PR templates |
| TypeScript Scaffold | ${config.includeScaffold ? "Yes" : "No"} | Project structure and tooling |
| AI Context | ${config.includeAIContext ? "Yes" : "No"} | AGENTS.md for AI assistants |
| Docker | ${config.includeDocker ? "Yes" : "No"} | Container configuration |

---

## Stack Recommendations

Based on your decisions, here are technology recommendations:

${generateStackRecommendations(snapshot)}

---

## Next Steps

1. **Review this document** - Ensure the captured decisions reflect your intent
2. **Address unknowns** - Make decisions on any open questions
3. **Set up your repository** - Extract the ZIP and initialize git
4. **Configure services** - Set up CI/CD, hosting, database as needed
5. **Document as you go** - Create ADRs for new decisions

---

*This document was generated by [repOptics](https://github.com/bmccall17/repOptics) - a decision-clarity system for developer hygiene.*
`;

  return {
    markdown,
    filename: "DECISIONS.md",
  };
}

function formatDecisionsByCategory(snapshot: DecisionSnapshot): string {
  const sections: string[] = [];

  for (const category of QUESTION_CATEGORIES) {
    const categoryAnswers = snapshot.answers.filter((a) => {
      const q = getQuestionById(a.questionId);
      return q?.category === category.id;
    });

    if (categoryAnswers.length === 0) continue;

    let section = `### ${category.label}\n\n`;

    for (const answer of categoryAnswers) {
      const question = getQuestionById(answer.questionId);
      if (!question) continue;

      section += `**${question.text}**\n\n`;
      section += `_Why it matters:_ ${question.whyItMatters}\n\n`;

      if (answer.selectedOptionIds.length > 0) {
        for (const optionId of answer.selectedOptionIds) {
          const option = question.options.find((o) => o.id === optionId);
          if (!option) continue;

          section += `**Decision:** ${option.label}\n\n`;
          section += `${option.description}\n\n`;

          if (option.consequences.length > 0) {
            section += `_Consequences:_\n`;
            for (const c of option.consequences) {
              section += `- ${c}\n`;
            }
            section += "\n";
          }
        }
      } else {
        section += `**Decision:** Not yet decided\n\n`;
      }

      if (answer.customNote) {
        section += `_Note:_ ${answer.customNote}\n\n`;
      }
    }

    sections.push(section);
  }

  return sections.join("\n---\n\n");
}

function generateStackRecommendations(snapshot: DecisionSnapshot): string {
  const recommendations: string[] = [];

  // Helper to get selected option
  const getOption = (questionId: string): string | undefined => {
    const answer = snapshot.answers.find(a => a.questionId === questionId);
    return answer?.selectedOptionIds[0];
  };

  const runtime = getOption("runtime-type");
  const storage = getOption("data-storage");
  const auth = getOption("data-auth");
  const budget = getOption("cost-budget");
  const ci = getOption("guardrails-ci");
  const testing = getOption("guardrails-testing");
  const purpose = getOption("intent-purpose");

  // ============================================
  // HOSTING RECOMMENDATIONS (based on runtime + budget)
  // ============================================

  if (runtime === "static") {
    if (budget === "zero") {
      recommendations.push(
        "- **Hosting**: GitHub Pages (free, automatic from repo) or Cloudflare Pages (free, faster global CDN)"
      );
    } else {
      recommendations.push(
        "- **Hosting**: Cloudflare Pages (fast global CDN, generous free tier) or Netlify (great DX, preview deploys)"
      );
    }
  } else if (runtime === "serverless") {
    recommendations.push(
      "- **Hosting**: Vercel (optimized for Next.js, preview deploys) or Cloudflare Workers (edge computing, low latency)"
    );
  } else if (runtime === "server") {
    if (budget === "zero") {
      recommendations.push(
        "- **Hosting**: Render free tier (note: sleeps after 15 min inactivity, cold starts ~30s) or Fly.io free tier (similar limitations)"
      );
    } else if (budget === "hobby") {
      recommendations.push(
        "- **Hosting**: Render Starter ($7/mo, no sleep) or Railway ($5+/mo, usage-based)"
      );
    } else {
      recommendations.push(
        "- **Hosting**: Render or Railway (both excellent for production Node.js), or Fly.io for global distribution"
      );
    }
  } else if (runtime === "hybrid") {
    recommendations.push(
      "- **Hosting**: Vercel (best Next.js support, handles SSR + static seamlessly) or Netlify (good alternative)"
    );
  }

  // ============================================
  // DATABASE RECOMMENDATIONS (based on storage + budget + purpose)
  // ============================================

  if (storage === "database") {
    if (budget === "zero") {
      recommendations.push(
        "- **Database**: Supabase free tier (500MB Postgres, includes auth) or PlanetScale free tier (5GB MySQL)"
      );
    } else if (purpose === "production") {
      recommendations.push(
        "- **Database**: Supabase Pro ($25/mo, 8GB) or PlanetScale Scaler ($29/mo) for production workloads"
      );
    } else {
      recommendations.push(
        "- **Database**: Supabase (Postgres + auth + storage combo) or PlanetScale (MySQL with branching)"
      );
    }
  } else if (storage === "local") {
    recommendations.push(
      "- **Storage**: Browser localStorage (5MB limit) or IndexedDB (larger, async) - no server costs"
    );
  } else if (storage === "file") {
    recommendations.push(
      "- **Storage**: SQLite (single file, great for low-traffic apps) or JSON files (simplest)"
    );
  }

  // ============================================
  // AUTH RECOMMENDATIONS (based on auth type + purpose)
  // ============================================

  if (auth === "oauth") {
    if (purpose === "production") {
      recommendations.push(
        "- **Auth**: Clerk (polished UI, MFA, good DX) or Auth0 (enterprise features) - both have free tiers"
      );
    } else {
      recommendations.push(
        "- **Auth**: NextAuth.js (free, self-hosted, supports many providers) - best for internal tools"
      );
    }
  } else if (auth === "simple") {
    recommendations.push(
      "- **Auth**: Magic link via Resend (simple, passwordless) or Supabase Auth (if using Supabase DB)"
    );
  } else if (auth === "full") {
    recommendations.push(
      "- **Auth**: Clerk or Auth0 for managed auth, or Lucia (self-hosted, full control)"
    );
  }

  // ============================================
  // CI/CD RECOMMENDATIONS (based on ci + testing)
  // ============================================

  if (ci === "ci" || ci === "ci-cd") {
    recommendations.push(
      "- **CI/CD**: GitHub Actions (free for public repos, 2000 min/mo free for private)"
    );
  } else if (ci === "lint-only") {
    recommendations.push(
      "- **CI**: GitHub Actions with lint-only workflow (fast, catches obvious issues)"
    );
  }

  // ============================================
  // TESTING RECOMMENDATIONS (based on testing level)
  // ============================================

  if (testing === "unit" || testing === "full") {
    recommendations.push(
      "- **Testing**: Vitest (fast, Jest-compatible) + Testing Library (component tests)"
    );
  } else if (testing === "smoke") {
    recommendations.push(
      "- **Testing**: Playwright for smoke tests (catches broken pages/flows)"
    );
  }

  // ============================================
  // BUDGET-SPECIFIC NOTES
  // ============================================

  if (budget === "zero") {
    recommendations.push(
      "- **Budget Strategy**: Combine free tiers: Vercel/Cloudflare + Supabase + GitHub Actions = $0/mo for small projects"
    );
  } else if (budget === "enterprise") {
    recommendations.push(
      "- **Budget Strategy**: Consider managed services (Vercel Enterprise, AWS, GCP) for SLAs and support"
    );
  }

  // ============================================
  // PRODUCTION-SPECIFIC ADDITIONS
  // ============================================

  if (purpose === "production") {
    recommendations.push(
      "- **Monitoring**: Sentry (error tracking, free tier) or LogRocket (session replay)"
    );
  }

  if (recommendations.length === 0) {
    return "_No specific stack recommendations based on current decisions. Answer more questions for tailored suggestions._";
  }

  return recommendations.join("\n");
}

/**
 * Generate a minimal handoff for cases where the decision wizard wasn't used
 * (backwards compatibility with existing generator flow)
 */
export function generateSimpleHandoff(config: ProjectConfig): HandoffDocument {
  const timestamp = new Date().toISOString().split("T")[0];

  const markdown = `# ${config.projectName} - Project Setup

> Generated by repOptics Project Generator on ${timestamp}

## Overview

**Project**: ${config.projectName}
**Description**: ${config.description || "(No description provided)"}

## Generated Configuration

| Module | Included |
|--------|----------|
| ADR Templates | ${config.includeADR ? "Yes" : "No"} |
| CI/CD Pipeline | ${config.includeCI ? "Yes" : "No"} |
| Governance Files | ${config.includeGovernance ? "Yes" : "No"} |
| TypeScript Scaffold | ${config.includeScaffold ? "Yes" : "No"} |
| AI Context | ${config.includeAIContext ? "Yes" : "No"} |
| Docker | ${config.includeDocker ? "Yes" : "No"} |

## Next Steps

1. Extract the ZIP and initialize git: \`git init\`
2. Install dependencies: \`npm install\` (if scaffold included)
3. Review and customize the generated files
4. Create your first ADR documenting key project decisions

---

*Generated by [repOptics](https://github.com/bmccall17/repOptics)*
`;

  return {
    markdown,
    filename: "DECISIONS.md",
  };
}
